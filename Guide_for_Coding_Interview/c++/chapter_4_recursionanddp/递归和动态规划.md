# 递归和动态规划

## 斐波那契系列问题的递归和动态规划
```
【题目】
	给定整数N，返回斐波那契数列的第N项。
	
【补充题目1】
	给定整数N，代表台阶数，一次可以跨2个或者1个台阶，返回有多少中走法；
	
	举例：
	N=3,可以三次都跨1个台阶；也可以先跨2个台阶，再跨1个台阶；还可以先跨1个台阶，再跨2个台阶。所以有三种走法，返回3。
【补充题目2】
	假设农场中成熟的母牛每年只会生1个小母牛，并且永远不会死。第一年农场有1只成熟的母牛，从第二年开始，母牛开始生小母牛。每只小母牛3年之后成熟又可以生小母牛。给定整数N，求出N年后牛的数量。
	
	举例：
	N=6，第1年1头成熟母牛记为a；第2年a生了新的小母牛，记为b，总牛数为2；第3年a生了新的小母牛，记为c，总牛数为3；第4年a生了新的小母牛，记为d，总牛数为4。第5年b成熟了，a和b分别生了新的小母牛，总牛数为6；第6年c也成熟了，a、b和c分别生了新的小母牛，总牛数为9，返回9.
	
【要求】
	对以上所有问题，请实现时间复杂度O(logN)的解法。

【难度】
	*****
```
## 矩阵的最小路径和
```
【题目】
	给定一个矩阵m，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，返回所有的路径中最小的路径和。

【举例】
	如果给定的m如下：
	1	3	5	9
	8	1	3	4
	5	0	6	1
	8	8	4	0
	路径 1,3,1,0,6,1,0 是所有路径中路径和最小的，所以返回12.

【难度】
	**
	
```
## 换钱的最少货币数
```
【题目】
	给定数组 arr，arr 中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数 aim 代表要找的钱数，求组成 aim 的最少货币数。

【举例】
	arr=[5,2,3], aim=20。
	4张5元可以组成20元，其他的找钱方案都要使用更多张的货币，所以返回4.
	arr=[5,2,3], aim=0。
	不用任何货币就可以组成0元，返回0.
	arr=[3,5], aim=2。
	根本无法组成2元，钱不能找开的情况下默认返回-1.

【补充题目】
	给定数组 arr， arr 中的值都为正数。每个值仅代表一张钱的面值，在给定一个整数 aim 代表要找的钱数，求组成aim的最小货币数。

【举例】
	arr=[5,2,3], aim=20。
	5元、2元和3元的钱各一张，所以无法组成20元，默认返回-1。
	arr=[5,2,5,3], aim=10。
	5元的货币有2张，可以组成10元，且该方案所需张数最少，返回2。
	arr=[5,2,5,3], aim=15。
	所有的钱加起来才组成15元，返回4。
	arr=[5,2,5,3], aim=0。
	不用任何货币就可以组成0元，返回0。
	
【难度】
	**
	
```
## 换钱的方法数
```
【题目】
	给定数组 arr， arr 中所有的值都为正数且正数不重复。每个值代表一中面值的货币，每种面值的货币可以使用任意张，在给定一个正数aim代表要找的钱数，求换钱有多少种方法。
	
【举例】
	arr=[5,10,25,1], aim = 0。
	组成0元的方法有1种，就是所有的面值都不用。所以返回1；
	arr=[5,10,25,1], aim = 15。
	组成15元的方法有6种，分别是 3 张 5 元、1 张 10 元 + 1 张 5 元、1张10元+5张1元、10张1元+1张5元、2张5元+5张1元和15张1元。所以反馈6。
	arr=[3,5],aim=2。
	任何方法都无法组成2元。所以返回0。
	
【难度】
	**

```

## 最长递增子序列
```
【题目】
	给定数组arr，返回arr的最长递增序列。

【举例】
	arr=[2,1,5,3,6,4,8,9,7], 返回的最长递增子序列为[1,3,4,8,9]。
	
【要求】
	如果arr长度为N,请时间时间复杂度为O(NlogN)的方法。

【难度】
	***
	
```

## 汉诺塔问题
```
【题目】
	给定一个整数 n, 代表汉诺塔游戏中从小到大放置的 n 个圆盘，假设开始是所有的圆盘都放在左边的柱子上，想按照汉诺塔游戏的要求把所有的圆盘都移动到右边的柱子上。实现函数打印最优移动轨迹。
	
【举例】
	n = 1时，打印：
	move from left to right.
	n = 2时，打印：
	move from left to mid
	move from left to right
	move from mid to right
	
【进阶题目】
	给定一个整数数组 arr, 其中只含有1、2 和 3，代表所有圆盘目前的状态， 1 代表左柱，2代表中柱，3代表右柱，arr[i]的值代表第 i + 1个圆盘的位置。比如，arr=[3,3,2,1], 代表第1个圆盘在右柱上、第2个圆盘在右柱上、第3个圆盘在中柱上、第4个圆盘在左柱上。如果arr代表的状态是最优移动轨迹过程中出现的状态，返回arr这种状态是最优移动轨迹中的第几个状态。如果arr代表的状态不是最优移动轨迹过程中出现的状态，则返回-1。
	
【举例】
	arr=[1,1]。两个圆盘目前都在左柱上，也就是初始状态，所以返回0。
	arr=[2,1]。第一个圆盘在中柱上、第二个圆盘在左柱上，这个状态是 2 个圆盘的汉诺塔游戏汇总的最优移动轨迹的第 1 步，所以返回 1。
	arr=[3,3]。第一个圆盘在右柱上、第二个圆盘在右柱上，这个状态是 2 个圆盘的汉诺塔游戏汇总的最优移动轨迹的第 3 步，所以返回 3。
	arr=[2,2]。第一个圆盘在中柱上、第二个圆盘在中柱上，这个状态是 2 个圆盘的汉诺塔游戏汇总的最优移动轨迹从来不会出现的状态，所以返回 -1。

【进阶题目要求】
	如果 arr 长度为N，请实现时间复杂度为 O(N)、额外空间复杂度为O(1)的方法。

【难度】
	***

```

## 最长公共子序列问题
```
【题目】
	给定两个字符串 str1 和 str2，返回两个字符串的最长公共子序列。

【举例】
	str1="1A2C3D4E56", str2="B1D23CA45B6A"
	"123456"或者"12C4B6"都是最长公共子序列，返回哪一个都行。
	
【难度】
	**

```
## 最长公共子串
```
【题目】
    给定两个字符串 str1 和 str2，返回两个字符串的最长公共子串。
 
【举例】
	str1="1AB2345CD", str2="12345EF"，返回"2345"
	
【要求】
	如果str1 长度为M, str2 长度为N，实现时间复杂度为O(MxN), 额外空间复杂度为O(1)的方法。

【难度】
	***
	
```

## 最小编辑代价
```
【题目】
    给定两个字符串 str1 和 str2，再给定三个整数ic、dc和rc，分别代表插入、删除和替换一个字符的代价，返回将str1编辑成str2的最小代价。
 
【举例】
    str1="abc", str2="adc"，ic=5, dc=3, rc=2。
    从"abc"编辑成"adc", 把'b'替换成'd'是代价最小的，所以返回2。
    str1="abc", str2="adc"，ic=5, dc=3, rc=100。
    从"abc"编辑成"adc", 先删除'b',然后在插入'd'是代价最小的，所以返回8。
    str1="abc", str2="abc"，ic=5, dc=3, rc=2。
	从"abc"编辑成"abc", 不用编辑，所以返回0。

【难度】
    ***
```

## 字符串的交错组成
```
【题目】
    给定三个字符串 str1、str2和aim，如果aim包含且仅包含来自str1和str2的所有字符串，而且在aim中属于str1的字符串之间博爱吃原来在str1中的顺序，属于str2的字符之间保持原来在str2中的顺序，那么称aim是str1和str2的交错组成。实现一个函数，判断aim是否是str1和str2交错组成。
    
【举例】
	str1="AB", str2="12"。那么"AB12"、"A1B2"、"A12B"、"1A2B"和"1AB2"等都是str1和str2的交错组成。
	
【难度】
	***
```

## 龙与地下城游戏问题
```
【题目】
	给定一个二维数组 map, 含义是一张地图，例如，如下矩阵：
	
	-2	-3	 3
	-5	-10	 1
	0 	30	-5
	
	游戏规则如下：
	1. 骑士从左上角出发，每次只能向右或向下走，最后到达右下角见到公主。
	2. 地图中每个位置的值代表骑士要遭遇的事情。如果是负数，说明此处有怪兽，要让骑士损失血量
```

## 数字字符串转换为字母组合的种数
```
【题目】

　　给定一个字符串str，str全部由数字字符组成，如果str中某一个或者某相邻两个字符组成的子串在1~26之间，则这个子串可以转换为一个字母。规定“1”转换为“A”，“2”转换为“B”……“26”转换为“Z”。求str有多少种不同的转换结果。

【举例】
　　str = “1111” 
　　能转换成的结果有“AAAA”，“LAA”，“ALA”，“AAL”和“LL”，返回5。 
　　str = “01”，“0”没有对应的字母，返回0。

【基本思路】 
	1.暴力递归的方法。定义递归函数p(i)，p(i)表示只转换字符串的i～N-1部分（N表示字符串的长度），一共有多少种转换结果。接下来便可以进行递归求解：
		如果i == N，p(N)表示没有任何字符需要转换，返回 1。
		如果str[i] == ‘0’，因为以0开头的子串都能进行转换，所以返回 0。
		如果不满足条件1和2，说明此时str[i]在 ‘1’ 到 ‘9’ 之间，这个时候str[i]能转换的种数至少包含p(i+1)。如果str[i]和str[i+1]的组合又在 ‘10’ 到 ‘26’ 之间，则str[i]能转换的种数还要包含p(i+2)，即ｐ(i) = p(i+1) 或者p(i) = p(i+1) + p(i+2)。
	
	2.动态规划的方法。由上述可知，p(i)的值最多依赖于p(i+1)和p(i+2)，即p(i) = p(i+1) (+ p(i+2))，这就是典型的斐波那契问题的变形题，只不过这里是从后往前计算而已。
	
```

## 排成一条线的纸牌博弈问题
```
【题目】
	给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左边或者最右边的一张牌，最后所拿牌累加和最大的玩家获胜，玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。

【举例】
	arr = [1, 2, 100, 4]
	玩家A先拿1，玩家B拿4，玩家A再拿100，玩家B再拿2，游戏结束，玩家A获胜，分数为101。
　　
【基本思路】
	首先分析暴力递归的方法。定义递归函数f(i, j)表示如果arr[i…j]这个排列上的纸牌被绝顶聪明的人先拿，最终会获得什么分数。定义递归函数s(i, j)，表示如果arr[i…j]这个排列上的纸牌被绝顶聪明的人后拿，最终能获得什么分数。

	首先分析f(i, j)，具体过程如下：
	
	如果i == j，表示此时只有一张牌，当然会被先拿牌的人拿走，所以返回arr[i]即可。
	
	如果i != j，那么此时有两种选择，一种是先拿arr[i]，一种是先拿arr[j]。如果先拿走arr[i]，那么对于剩下的arr[i+1…j]，玩家成了后拿牌的人，所以他能获得的分数为arr[i] + s(i+1, j)；同理如果先拿arr[j]，那么他能获得的分数为arr[j] + s(i, j-1)。因为玩家是决定聪明的人，所以他会选择两个决策中最优的，即max(arr[i] + s(i+1, j), arr[j] + s(i, j-1))。
	
	接下来分析s(i, j)，具体过程如下：

	如果i == j，表明此时只有一张牌，对于后拿牌的人来说，他肯定拿不上，说以返回 0。

	如果i != j，那么此时玩家的拿牌方式其实受到对手的影响，如果对手选择的是arr[i]那么给玩家留下的就是arr[i+1…j]，对于排列arr[i+1…j]玩家成了先拿牌的人，所以他能得到的分数为f(i+1, j)。同理，如果对手选择的是arr[j]那么给玩家留下的就是arr[i…j-1]，对于排列arr[i…j-1]玩家成了先拿牌的人，所以他能得到的分数为f(i, j-1)。因为对手也是绝顶聪明的，所以留给玩家的一定是最坏的情况，所以玩家只能选择两个决策中最差的，即max(f(i+1, j), f(i, j-1))。
	
```

## 跳跃游戏
```
【题目】
　　给定数组arr，arr[i] == k代表可以从位置i向右跳1～k个距离。比如，arr[2] == 3，代表从位置2可以跳到位置3、位置4或者位置5。如果从位置0出发，返回最少跳几次能跳到arr最后的位置上。

【举例】
	arr = [3, 2, 3, 1, 1, 4] 
	arr[0] = 3，选择跳到位置2；arr[2] == 3，可以跳到最后的位置，所以返回2。

【基本思路】
	1.使用3个变量，jump，cur，next。jump表示目前跳了多少次，cur表示跳了jump下后能到达的最远距离，next表示如果再跳一次能到达的最远位置。初始时三个变量都为0。
	
	2.从左到右依次遍历数组arr，假设遍历到位置i，分析如下：
	如果i <= cur，说明跳jump次可以到达位置i，此时不需要进行任何操作。
	如果i > cur，说明此时跳jump次不能到达位置i，需要再跳一次才行。此时令jump + 1，cur = next。表示多跳了一次，cur更新成跳jump + 1次能到达的最远距离。
	更新next，next = max(next, i + arr[i])，表示下一次多跳一次能到达的最远距离。
	
```

## 数组中的最长连续序列
```
【题目】
	给定无序数组，返回其中最长的连续序列的长度。
	
【举例】
	arr = [100, 4, 200, 1, 3, 2]，最长的连续序列为[1, 2, 3, 4]，所以返回4。

【基本思路】

	利用哈希表可以实现时间、空间复杂度都为O(N)的方法。具体过程如下：

	生成哈希表map，key表示遍历过的某个数，value代表key这个数所在的最长连续序列的长度。

	从左到右依次遍历数组，假设遍历到arr[i]，如果arr[i]已经存在于map中，直接跳过，这是因为最长的连续序列必定不包含相同的值。如果arr[i]不存在与map中，则将arr[i]作为key添加到map中，其value值设为1，表示目前arr[i]单独作为一个连续序列。

	之后，在map表中查找是否含有arr[i]-1，如果有，说明arr[i]-1和arr[i]可以合并，合并之后记录新序列的长度len、最大值lmax和最小值lmin，将map表中key为lmax，lmin的value值更新为len；

	同理在map表中查找是否含有arr[i]+1，如果有，说明arr[i]和arr[i] + 1可以合并，合并之后记录新序列的长度len、最大值rmax和最小值rmin，将map表中key为rmax，rmin的value值更新为len。

	遍历过程中用全局变量max记录每次合并出的序列的长度的最大值，最后返回max。
```

## N皇后问题的递归方法和位运算方法
```
【题目】

	N皇后问题是指在N×N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列，也不在同一条斜线上。给定一个整数N，返回N个皇后的摆法有多少种。

【基本思路】

	1.递归方法。如果在位置（i，j）放置了一个皇后，那么那些位置就不能在放置皇后了呢？
		整个 i 行都不能放置
		整个 j 行都不能放置
		如果位置（a，b）满足 |a - i| = |b - j|，说明（a，b）与（i，j）处在同一条斜线上，也不能放置皇后。
		把递归过程设计成逐行放置皇后的方式，可以避开条件 1 的那些不能放置的位置。接下来用一个数组保存已经放置的皇后的位置，假设数组为record，record[i] == k，表示第 i 行的皇后放置在了第 k 列。在递归计算到第 i 行，都要判断该行的每一个位置是否可以放置皇后。
	2. 位运算法。
		其实位运算的方法的思路也是递归，只不过是使用了位运算进行了加速，将每一个位置能否放置皇后用 0 和 1 来表示。代码如下：
		其中upperLim表示的是棋盘的每一列都有皇后放置的情况，也就是N皇后摆放成功的结果。初始值将每一列都设为 1，用作递归终止的条件判断。
		colLim表示递归到上一行为止，哪些列已经放置了皇后，放置的用 1 表示，否则用 0 表示。
		leftDiaLim表示递归到上一行为止，受已经放置的皇后的左下方斜线的影响而不能放置的位置， 1 表示不能放置，0 表示可以放置。
		rightDiaLim表示递归到上一行为止，受已经放置的皇后的右下方斜线的影响而不能放置的位置， 1 表示不能放置，0 表示可以放置。
		pos表示当前行在colLim，leftDiaLim，rightDiaLim限制下能放置的位置，1表示可以放置，0表示不可以放置。
		mostRightOne表示pos的最右边的 1 的位置。从右到左遍历每一个可以放置皇后的位置。
		
```